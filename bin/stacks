#!/opt/ruby-bundle/bin/ruby

if ENV['dev']
  $LOAD_PATH << 'lib/'
else
  $LOAD_PATH << '/usr/local/lib/site_ruby/timgroup/'
end

require 'getoptlong'

require 'stackbuilder/stacks/factory'
require 'stackbuilder/support/logger'
require 'stackbuilder/support/cmd'

def help
  puts <<END
stacks - the infrastructure manager

Description:
  stacks is a front end tool for the stackbuilder library, used to bring up and destroy stacks of
  virtual machines, as well as perform other administrative tasks.

Usage: stacks [OPTIONS] command
       stacks --help

Options:
  General options:

    -h, --help                      display this help and exit
    -p, --path=VALUE                path to the stackbuilder-config repository. "/etc/stacks" is the default. See also STACKBUILDER_CONFIG_PATH
    -v, --verbose                   increase logging verbosity. Can be specified multiple times (e.g. -vvv)
    -q, --quiet                     reduce logging verbosity. Can be specified multiple times (e.g. -qqq)
    -c, --checkout-config=VALUE     make a new temporary clone of stackbuilder-config for this command (ignores the --path option)
                                    The clone is made from the VALUE git remote (defaults to 'git@git:stackbuilder-config')
                                    The clone is deleted after the command completes

  Options that may affect commands. Depending on "command", some of these may be mandatory, optional, or ignored.

    -e, --environment=VALUE         set the environment to operate on. "dev" is the default
    -s, --stack=VALUE               select the stack
    -t, --terse                     shorten the output
    --create-persistent-storage     allocate new persistent storage, instead of finding existing storage
                                    (WARNING: normally only wanted when provisioning a stack for the first time)

  For further information about options, read bin/stacks.

  The list of commands follows. Optional and mandatory options are outlined.

    audit [-e]                show the state of the KVM host machines
    clean [-e] -s             shuts down and removes a stack, but retains configuration (puppet, nagios, mongo)
    clean_all [-e] -s         shuts down and removes a stack, puppet, nagios and mongo
    compile                   create a yaml file describing the entire infrastructure
    dependencies [-e] -s      list the machines that this machine depends on
    dependents [-e] -s        list the machines that depend on this machine
    diff                      show compile diff between last commit and latest commit.
    diff -sb                  show compile diff between latest stackbuilder and local stackbuilder.
    dns [-e] -s               perform DNS related tasks
      allocate_ips            allocate all ip addresses for the specified stack (machine(s))
      free_ips                free all ip addresses for the specified stack (machine(s))
      allocate_vips           allocate all vip addresses for a stack (service(s))
      free_vips               free all vip addresses for a stack (service(s))
    enc [-e] -s               print the enc of the specified stack. Stack must be a single fqdn. Used for debugging
    spec [-e] -s              print the spec of the specified stack. Stack must be a single fqdn. Used for debugging
    ls [-est]                 show the entire environment. Show just one stack if -s is specified. If -t is specified,
                              skip stacks of type "machine".
    provision [-e] -s         allocates and spins up a stack
    reprovision [-e] -s       "clean", and then "provision" a stack
    terminus                  create a yaml puppet terminus

  For further information about commands, read lib/stackbuilder/support/cmd*.rb

Environment:
  BUILD_NUMBER              used to set the .deb package version. Used in Jenkins builds
  RUBYLIB                   set the path to the stackbuilder library. Used for testing and development
  STACKBUILDER_CONFIG_PATH  set the path to stackbuilder-config. The -p option takes precedence

Files:
  ~/.mc/                    directory with mcollective keys
  /etc/stacks/              default path to stackbuilder-confi
  /usr/local/bin/stacks     the stacks executable
  /usr/local/lib/site_ruby/timgroup/stackbuilder/
                            the stackbuilder library on production hosts
  /usr/lib/ruby/vendor_ruby/puppet/indirector/node/stacks.rb
                            stacks indirector, for puppet. This file is 'required' by puppet.
  /usr/local/bin/stacks_indirector
                            new stacks indirector, for puppet. This script is executed by puppet. Working but not in
                            use due to blockers

Examples:
  stacks compile > /tmp/enc_test
  stacks diff > /tmp/diff
  stacks diff -sb > /tmp/sb_diff
  stacks -e test ls -s refapp
  stacks -e test enc -s test-refapp-002.mgmt.st.net.local

Bugs:
END
end

# options with defaults. an arbitrary option can be set here, this is not an exclusive list.
$options = {
  :environment => 'dev',
  :path        => ENV['STACKBUILDER_CONFIG_PATH'] || '.',
  :verbose     => 2
}
# change the default path on puppetservers puppet.conf node_terminus does not take parameters
require 'socket'
$options[:path] = '/etc/stacks' if Socket.gethostname =~ /puppetserver/

# options with arguments go straight into $options
# unrecognized options are ignored
GetoptLong.new(
  ['--environment',     '-e', GetoptLong::REQUIRED_ARGUMENT],
  ['--help',            '-h', GetoptLong::NO_ARGUMENT],
  ['--path',            '-p', GetoptLong::REQUIRED_ARGUMENT],
  ['--stack',           '-s', GetoptLong::REQUIRED_ARGUMENT],
  ['--terse',           '-t', GetoptLong::NO_ARGUMENT],
  ['--verbose',         '-v', GetoptLong::NO_ARGUMENT],
  ['--quiet',           '-q', GetoptLong::NO_ARGUMENT],
  ['--checkout-config', '-c', GetoptLong::OPTIONAL_ARGUMENT],
  ['--create-persistent-storage', GetoptLong::NO_ARGUMENT]
).each do |opt, arg|
  opt_sym = opt[2..-1].to_sym
  case opt
  when '--help'
    help
    exit 0
  when '--verbose'
    $options[:verbose] += 1
  when '--quiet'
    $options[:quiet] -= 1
  when '--terse'
    $options[:terse] = true
  when '--checkout-config'
    $options[:'checkout-config'] = (arg == '') ? 'git@git:stackbuilder-config.git' : arg
  else
    $options[opt_sym] = arg
  end
end
cmd = ARGV.shift
argv = ARGV
logger(Logger::DEBUG) { "finished processing options. command: \"#{cmd}\", options: \"#{$options}\", argv: #{argv}" }

if $options[:'checkout-config']
  require 'tmpdir'
  $options[:path] = Dir.mktmpdir
  parent = Process.pid
  at_exit { FileUtils.remove_entry($options[:path]) if Process.pid == parent }

  if !system("git clone --quiet --depth 1 '#{$options[:'checkout-config']}' '#{$options[:path]}'")
    logger(Logger::FATAL) do
      "Unable to clone '#{$options[:'checkout-config']}'"
    end
    exit 1
  end
end

if File.directory?($options[:path])
  if !system("cd \"#{$options[:path]}\" && " \
            "(echo $(git config remote.origin.url) | grep -q 'stackbuilder-config')")
    logger(Logger::FATAL) do
      "stackbuilder-config path \"#{$options[:path]}\" is not a valid git repository.\n" \
      "Please specify a valid git repository using -p <stackbuilder-config-path>\n" \
      "See --help for more information."
    end
    exit 1
  end
else
  logger(Logger::FATAL) do
    "stackbuilder-config path \"#{$options[:path]}\" is not valid directory.\n" \
    "Please specify a valid git repository using -p <stackbuilder-config-path>\n" \
    "See --help for more information."
  end
  exit 1
end

if $options[:'create-persistent-storage']
  ENV['CREATE_PERSISTENT_STORAGE'] = 'true'
  logger(Logger::WARN) { '--create-persistent-storage is set so any persistent storage will be created, existing storage will not be reused' }
end

logger(Logger::DEBUG) { 'initializing $factory' }
$factory = Stacks::Factory.new
if ($environment = $factory.inventory.find_environment($options[:environment])).nil?
  logger(Logger::FATAL) { "environment \"#{$options[:environment]}\" not found" }
  exit 1
end
logger(Logger::DEBUG) { "environment \"#{$environment.name}\" has #{$environment.definitions.count} definitions" }

commands = CMD.new
if commands.cmds.include? cmd
  logger(Logger::DEBUG) { "about to execute command \"#{cmd}\"" }
  success = commands.method(cmd).call(argv)
  # FIXME: These are all the command that simply call system and return true/false.
  if %w(clean clean_all provision test reprovision).include? cmd
    unless success
      logger(Logger::FATAL) { "#{cmd} failed, check the output above" }
      exit 1
    end
  end
else
  if cmd.nil?
    logger(Logger::FATAL) { "no command specified.\nSee --help for more information." }
  else
    logger(Logger::FATAL) { "invalid command \"#{cmd}\".\nSee --help for more information." }
  end
  exit 1
end

exit 0
logger(Logger::DEBUG) { 'exiting gracefully' }
